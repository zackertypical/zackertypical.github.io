<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F19%2FUntitled%201%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F13%2F%E5%90%8E%E7%AB%AF%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[以及，提醒一下，接口返回类型一类的东西（就是模型里头用integer表示，且设有Module的类型）时，应该尽量用字符串表示，接收的时候也是 具体这种Module怎么用，可以看下ConstantHelper]]></content>
  </entry>
  <entry>
    <title><![CDATA[接口]]></title>
    <url>%2F2019%2F04%2F11%2FRails%20Active%20Record%2F</url>
    <content type="text"><![CDATA[查询接口以下是所有接口的列表 方法 用途 find 检索指定主键对应的对象 create_with distinct eager_load extending from group having includes joins left_outer_joins limit lock none offset order preload readonly references reorder reverse_order select where]]></content>
      <categories>
        <category>rails</category>
      </categories>
      <tags>
        <tag>rails</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F10%2Fruby%E8%AF%AD%E6%B3%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[hash哈希（Hash）本质上就是数组，只不过它的索引不局限于只能使用数字。哈希的索引（或者叫“键”）几乎可以使用任何对象。例如，可以使用字符串做键 函数参数常见参数有：必选参数，可选参数，带默认值的参数以及命名参数。 哈希作为参数12345def calculate(attributes = &#123;&#125;) @name = attributes[:name] @email = attributes[:email]end 参数的默认值是一个空哈希，所以我们可以定义一个没有名字或没有电子邮件地址的用户。如果键不存在会返回nil，所以如果没定键，attributes[:name]会返回nil。 命名参数函数调用的每个参数定义一个专门的名称。 12345678def foo(str: "foo", num: 424242) [str,num]endfoo(str: 'buz', num: 9) #=&gt; ['buz', 9]foo(str: 'bar') # =&gt; ['bar', 424242]foo # =&gt; ['foo', 424242]foo(bar: 'buz') # =&gt; ArgumentError 想使用命名参数，但又不想提供默认值，即调用函数时必须传入该参数。 1234567def special(a:, b:2) p [a, b]endspecial b: 4 # =&gt; ArgumentError: missing keyword: aspecial a: 12, b: 10 #=&gt; [12, 10]special 12, b: 10 # =&gt; ArgumentError: wrong number of arguments (given 1, expected 0) 12345678def mm (a, b=2, *c) #a必选，b带默认值，c可选 p [a, b, c]endmm(1) # =&gt; [1, 2, []]mm(1,10) # =&gt; [1, 10, []]mm(1, 10, 20, 21) #=&gt; [1, 10, [20, 21]] 函数返回值]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令行汇总]]></title>
    <url>%2F2019%2F04%2F10%2FLinux%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[进程 命令 操作 ps 报告当前进程快照 top 动态查看进程 jobs 列出活跃的任务 bg 把任务放到后台执行 fg 把任务放到前台执行 kill 给一个进程发送信号 killall 杀死指定名字的进程 shutdown 关机或重启系统 把进程放到后台执行 进程返回到前台 一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用Ctrl-C 来中断它。使用 fg 命令，让一个进程返回前台执行。 fg 命令之后，跟随着一个百分号和工作序号（叫做 jobspec）。如果只有一个后台任务，那么 jobspec 是可有可无的。 12345678$ jobs[1] Stopped vim[2] Stopped vim aa[3] Stopped vim sdkfj[4]- Stopped vim kkk[5]+ Stopped vim abc$ fg %4#回到vim kkk 杀死一个进程 12345$ kill -[signal] PID...#signal可以用号码也可以用符号#符号前面要加SIG，以下命令作用相同$ kill -9 433$ kill -SIGKILL 433 列出所有信号 1$ kill -l 常用信号： 编号 名字 含义 1 HUP 2 INT 9 KILL 15 TERM 18 CONT 19 STOP 3 QUIT 11 SEGV 20 TSTP 软件包打包系统 包管理系统 发行版 (部分列表) Debian Style (.deb) Debian, Ubuntu, Xandros, Linspire Red Hat Style (.rpm) Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS 包管理系统 发行版 底层工具 上层工具 Debian-Style dpkg apt-get, aptitude Fedora, Red Hat Enterprise Linux, CentOS rpm yum 查找资源库中的软件包 风格 命令 Debian apt-get update; apt-cache search search_string Red Hat yum search search_string 从资源库中安装一个软件包 风格 命令 Debian apt-get update; apt-get install package_name Red Hat yum install package_name 通过软件包文件来安装软件如果从某处而不是从资源库中下载了一个软件包文件，可以使用底层工具来直接（没有经过依赖解析）安装它。 风格 命令 Debian dpkg –install package_file Red Hat rpm -i package_file 卸载软件 风格 命令 Debian apt-get remove package_name Red Hat yum erase package_name 经过资源库来更新软件包 风格 命令 Debian apt-get update; apt-get upgrade Red Hat yum update 列出所安装的软件包 风格 命令 Debian dpkg –list Red Hat rpm -qa 确定是否安装了一个软件包 风格 命令 Debian dpkg –status package_name Red Hat rpm -q package_name 查找安装了某个文件的软件包 风格 命令 Debian dpkg –search file_name Red Hat rpm -qf file_name 网络系统 ping - 发送 ICMP ECHO_REQUEST 数据包到网络主机 这个 ping 命令发送一个特殊的网络数据包，叫做 ICMP ECHO_REQUEST，到 一台指定的主机。大多数接收这个包的网络设备将会回复它，来允许网络连接验证。 traceroute - 打印到一台网络主机的路由数据包 netstat - 打印网络连接，路由表，接口统计数据，伪装连接，和多路广播成员 netstat 程序被用来检查各种各样的网络设置和统计数据。通过此命令的许多选项，我们 可以看看网络设置中的各种特性。使用“-ie”选项，我们能够查看系统中的网络接口 ftp - 因特网文件传输程序 wget - 非交互式网络下载器 ssh - OpenSSH SSH 客户端（远程登录程序） -r, --route display routing table -i, --interfaces display interface table -g, --groups display multicast group memberships -s, --statistics display networking statistics (like SNMP) -M, --masquerade display masqueraded connections -v, --verbose be verbose -W, --wide don&apos;t truncate IP addresses -n, --numeric don&apos;t resolve names --numeric-hosts don&apos;t resolve host names --numeric-ports don&apos;t resolve port names --numeric-users don&apos;t resolve user names -N, --symbolic resolve hardware names -e, --extend display other/more information -p, --programs display PID/Program name for sockets -o, --timers display timers -c, --continuous continuous listing -l, --listening display listening server sockets -a, --all display all sockets (default: connected) -F, --fib display Forwarding Information Base (default) -C, --cache display routing cache instead of FIB -Z, --context display SELinux security context for sockets]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F09%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E8%81%94%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[建立模型： User Relationship ​ 两种关系： 主动关注 被动被关注 模型代码： 12345678class User &lt; ApplicationRecord has_many :active_relationships, class_name: "Relationship", foreign_key: "follower_id", dependent: :destroy #active_relationships是自己取的名字，不是默认的模型名字， #class_name是模型的类名，需要指定（如果active_relationships取名为relationships则不需要） #Rails 会寻找名为&lt;class&gt;_id 的外键，其中&lt;class&gt; 是模型类名的小写形式end 1234567class Relationship &lt; ApplicationRecord belongs_to :follower, class_name: "User" #follower和followed都是自己取的名字，都属于User的类 belongs_to :followed, class_name: "User" validates :follower_id, presence: true validates :followed_id, presence: true end 以上代码建立的方法： 方法 作用 active_relationship.follower 获取关注我的用户 active_relationship.followed 获取我关注的用户 user.active_relationships.create(followed_id: other_user.id) 创建user 发起的主动关系 user.active_relationships.create!(followed_id: other_user.id) 创建user 发起的主动关系（失败时抛出异常） user.active_relationships.build(followed_id: other_user.id) 构建user 发起的主动关系对象 如何获取我关注（following)和关注我(followers)的账户 默认情况下，在has_many :through 关联中，Rails 会寻找关联名单数形式对应的外键。 1has_many :followeds, through: :active_relationships 如果不是默认情况，Rails 允许定制的关联方法：使用source 参数指定following 数组由followed_id组成 1has_many :following, through: :active_relationships, source: :followed 我们可以充分利用 Active Record 和数组的功能。例如，可以使用include? 方法检查我关注的用户中有没有某个用户，或者通过关联查找一个用户： 1234user.following.include?(other_user)user.following.find(other_user)user.following.count#很多情况下都可以把following 当成数组来用.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F08%2Fpython%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[SQLAlchemy数据库连接123from sqlalchemy import create_engineengine = create_engine('mysql+pymysql://root:123456@localhost:3306/test',echo=True) create_engine()返回一个Engine的实例，并且它表示通过数据库语法处理细节的核心接口，在这种情况下，数据库语法将会被解释称Python的类方法。 连接 echo参数为True时，会显示每条执行的sql语句。 1234567891011121314151617181920from sqlalchemy import Columnfrom sqlalchemy.types import CHAR, Integer, Stringfrom sqlalchemy.ext.declarative import declarative_baseBaseModel = declarative_base()def init_db(): BaseModel.metadata.create_all(engine) #找到 BaseModel 的所有子类，在数据库建立此表def drop_db(): BaseModel.metadata.drop_all(engine) #删除所有子表class User(BaseModel): __tablename__ = 'user' #数据库表名 id = Column(Integer, primary_key=True) name = Column(CHAR(30)) # or Column(String(30))init_db() declarative_base()declarative_base() 创建了一个 BaseModel 类，这个类的子类可以自动与一个表关联。以 User 类为例，它的__tablename__ 属性就是数据库中该表的名称，它有 id 和 name 这两个字段，分别为整型和 30 个定长字符。最后，BaseModel.metadata.create_all(engine) 会找到 BaseModel 的所有子类，并在数据库中建立这些表；drop_all() 则是删除这些表。]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql]]></title>
    <url>%2F2019%2F04%2F07%2Fmysql%2F</url>
    <content type="text"><![CDATA[安装： 123$ sudo apt-get install mysql-server$ sudo apt-get install mysql-client$ sudo apt-get install libmysqlclient-dev 开始进入root用户的时候一定记得加sudo 1$ sudo mysql -u root -p 常用指令： 12345678$ sudo service mysql start$ sudo service mysql stop$ sudo service mysql status或者$ systemctl start mysql$ systemctl stop mysql$ systemctl status mysql 用户操作操作之前首先要进入到mysql的终端下工作 1$ mysql -u &lt;用户名&gt; -p 然后输入密码 创建用户12345CREATE USER &lt;&apos;用户名&apos;@&apos;主机号&apos;&gt; IDENTIFIED BY &lt;&apos;密码&apos;&gt;;# examples:CREATE USER &apos;dog&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;;CREATE USER &apos;pig&apos;@&apos;192.168.1.101_&apos; IDENDIFIED BY &apos;123456&apos;; username：你将创建的用户名 host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符% password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器 授权123456GRANT &lt;权限名&gt; ON &lt;数据库名.表名&gt; TO &lt;&apos;用户名&apos;@&apos;主机号&apos;&gt;#examplesGRANT SELECT, INSERT ON test.user TO &apos;pig&apos;@&apos;%&apos;;GRANT ALL ON *.* TO &apos;pig&apos;@&apos;%&apos;;GRANT ALL ON maindataplus.* TO &apos;pig&apos;@&apos;%&apos;; privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL databasename：数据库名 tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.* 更改用户密码1SET PASSWORD FOR &apos;username&apos;@&apos;host&apos; = PASSWORD(&apos;newpassword&apos;);]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F07%2FRedis%2F</url>
    <content type="text"><![CDATA[redis]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F07%2F%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[windows快捷键 win+数字，开启下方菜单栏中对应的应用 cmder git bash snipaste listary typora]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F07%2Fpycharm%E8%BF%9C%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/autoliuweijie/article/details/80701915 https://blog.csdn.net/lin_danny/article/details/82185023 开启ssh https://blog.csdn.net/j790675692/article/details/52798953?utm_source=blogxgwz6 然后直接在pycharm的终端窗口开启调试： python manage.py runserver 0.0.0.0:8000 不能直接runserver 1Invalid HTTP_HOST header: &apos;192.168.163.140&apos;. You may need to add &apos;192.168.163.140&apos; to ALLOWED_HOSTS. 在settings.py 1ALLOWED_HOSTS = [&apos;132.232.182.190&apos;]]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F05%2Frails%E8%B7%AF%E7%94%B1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[URL地址连接到代码请求： 1GET /patients/17 会查询routes，找到匹配的controller的方法，如果匹配以下路由： 1get '/patients/:id', to: 'patients#show' 该请求会被分派给 patients 的controller的 show 方法，同时把 { id: &#39;17&#39; } 传入 params。 配置路由的路径：config/routes.rb 跟路由：root resource资源路由：rails默认风格资源路由（resource routing）允许我们为resource的controller快速声明所有常见路由。 只需一行代码即可完成资源路由的声明，包含方法index、show、new、edit、create、update 和 destroy 。 1、网络资源浏览器使用特定的 HTTP 方法向 Rails 应用请求页面，例如 GET、POST、PATCH、PUT 和 DELETE。每个 HTTP 方法对应对资源的一种操作。资源路由会把多个相关请求映射到单个controller的不同方法上。 当 Rails 应用收到下面的请求： 1DELETE /photos/17 会查询路由，并把请求映射到控制器动作上。如果第一个匹配的路由是： 1resources :photos Rails 会把请求分派给 photos 控制器的 destroy 动作，并把 { id: &#39;17&#39; } 传入 params。 2、CRUD、HTTP 方法和控制器动作资源路由把 HTTP 方法和 URL 地址映射到控制器动作上。按照约定，每个控制器动作也会映射到对应的数据库 CRUD 操作上。 1resources :photos 会在应用中创建 7 个不同的路由，这些路由都会映射到 Photos 控制器上。 因为路由使用 HTTP 方法和 URL 地址来匹配请求，所以 4 个 URL 地址会映射到 7 个不同的控制器动作上。 HTTP 方法 路径 控制器#动作 用途 GET /photos photos#index 显示所有照片的列表 GET /photos/new photos#new 返回用于新建照片的 HTML 表单 POST /photos photos#create 新建照片 GET /photos/:id photos#show 显示指定照片 GET /photos/:id/edit photos#edit 返回用于修改照片的 HTML 表单 PATCH/PUT /photos/:id photos#update 更新指定照片 DELETE /photos/:id photos#destroy 删除指定照片 3、_path和_url方法：用于生成PATH和 URL 地址在创建资源路由时，会同时创建多个可以 在控制器中使用的 辅助方法。例如，在创建 resources :photos 路由时，会同时创建下面的辅助方法： photos_path 辅助方法，返回值为 /photos new_photo_path 辅助方法，返回值为 /photos/new edit_photo_path(:id) 辅助方法，返回值为 /photos/:id/edit（例如，edit_photo_path(10) 的返回值为 /photos/10/edit） photo_path(:id) 辅助方法，返回值为 /photos/:id（例如，photo_path(10) 的返回值为 /photos/10） 这些辅助方法都有对应的 _url 形式（例如 photos_url）。 path方法返回值是相对路径。 url方法返回值是路径加上由当前的主机名、端口和路径前缀组成的前缀。 4、单数资源不使用ID就能查询到资源 创建限制默认情况下，Rails 会为每个 REST 式路由创建 7 个默认动作（index、show、new、create、edit、update 和 destroy）。我们可以使用 :only 和 :except 选项来微调此行为。:only 选项用于指定想要生成的路由： 1234resources :photos, only: [:index, :show]#/photos 路径上的 GET 请求会成功，而 POST 请求会失败，因为后者会被映射到 create 动作上。resources :photos, except: :destroy#此时，Rails 会创建除 destroy 之外的所有路由，因此 /photos/:id 路径上的 DELETE 请求会失败。 非资源型路由1、绑定参数12get 'photos(/:id)', to: :display#id在括号中，是可选参数 2、动态片段带冒号的片段，会传入params，在控制器中使用 1get 'photos/:id/:user_id', to: 'photos#show' /photos/1/2 路径会被映射到 Photos 控制器的 show 动作上。此时，params[:id] 的值是 &quot;1&quot;，params[:user_id] 的值是 &quot;2&quot;。 3、静态片段4、查询字符串params 也包含了查询字符串中的所有参数。例如，对于下面的路由： 1`get ``'photos/:id'``, to: ``'photos#show'` /photos/1?user_id=2 路径会被映射到 Photos 控制器的 show 动作上，此时，params 的值是 { controller: &#39;photos&#39;, action: &#39;show&#39;, id: &#39;1&#39;, user_id: &#39;2&#39; }。 5、路由命名1get 'exit', to: 'sessions#destroy', as: :logout 这个路由声明会创建 logout_path 和 logout_url 具名辅助方法。其中，logout_path 辅助方法的返回值是 /exit。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Virtualbox]]></title>
    <url>%2F2019%2F04%2F04%2Fvirtualbox%2Bvagrant%2F</url>
    <content type="text"><![CDATA[加速box安装的方法在网址中点击打开要安装的系统，在vagrant文件夹中执行 123456$ vagrant init ubuntu/xenial64A `Vagrantfile` has been placed in this directory. You are nowready to `vagrant up` your first virtual environment! Please readthe comments in the Vagrantfile as well as documentation on`vagrantup.com` for more information on using Vagrant. 我安装的是ubuntu/xenial64，接下来执行 1234567891011$ vagrant upBringing machine 'default' up with 'virtualbox' provider...==&gt; default: Box 'ubuntu/xenial64' could not be found. Attempting to find and install... default: Box Provider: virtualbox default: Box Version: &gt;= 0==&gt; default: Loading metadata for box 'ubuntu/xenial64' default: URL: https://vagrantcloud.com/ubuntu/xenial64==&gt; default: Adding box 'ubuntu/xenial64' (v20190325.0.0) for provider: virtualbox default: Downloading: https://vagrantcloud.com/ubuntu/boxes/xenial64/versions/20190325.0.0/providers/virtualbox.box default: Download redirected to host: cloud-images.ubuntu.com default: Progress: 0% (Rate: 61440/s, Estimated time remaining: 4:03:53) Ctrl+C终止下载，得到下载网址https://vagrantcloud.com/ubuntu/boxes/xenial64/versions/20190325.0.0/providers/virtualbox.box 然后复制到迅雷链接里下载。 下载得到文件virtualbox.box，复制文件夹下，执行指令 1$ vagrant box add ubuntu/xenial64 virtualbox.box 查看是否安装成功： 12$ vagrant listubuntu/xenial64 (virtualbox, 0) 接下来 1$ vagrant up 用xshell登录 在vagrant文件夹下输入 1234567891011$ vagrant ssh-configHost default HostName 127.0.0.1 User vagrant Port 2222 UserKnownHostsFile /dev/null StrictHostKeyChecking no PasswordAuthentication no IdentityFile C:/vagrant/ubuntu/.vagrant/machines/default/virtualbox/private_key IdentitiesOnly yes LogLevel FATAL 得到private_key的地址 root账户登录https://blog.csdn.net/github_38097011/article/details/83688607 1$ sudo -i 换源教程其他源：https://blog.csdn.net/qq_35451572/article/details/79516563 1、备份源文件： 123$ cd /etc/apt/$ sudo cp sources.list sources.list.bak $ sudo vim sources.list 2、删除原来的内容，替换以下 12345678910111213141516deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse ##测试版源 deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse # 源码 deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse ##测试版源 deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse # Canonical 合作伙伴和附加 deb http://archive.canonical.com/ubuntu/ xenial partner deb http://extras.ubuntu.com/ubuntu/ xenial main 3、更新源和软件 12$ sudo apt-get update #更新源$ sudo apt-get upgrade #更新软件 一些命令 12345678910111213141516sudo apt-get update 更新源sudo apt-get install package 安装包sudo apt-get remove package 删除包sudo apt-cache search package 搜索软件包sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等sudo apt-get install package --reinstall 重新安装包sudo apt-get -f install 修复安装sudo apt-get remove package --purge 删除包，包括配置文件等sudo apt-get build-dep package 安装相关的编译环境sudo apt-get upgrade 更新已安装的包sudo apt-get dist-upgrade 升级系统sudo apt-cache depends package 了解使用该包依赖那些包sudo apt-cache rdepends package 查看该包被哪些包依赖sudo apt-get source package 下载该包的源代码sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包sudo apt-get check 检查是否有损坏的依赖 安装rvm网络不是很稳定。。要是尝试很多次 1$ sudo curl -L get.rvm.io | bash -s stable 换掉源镜像 1$ echo "ruby_url=https://cache.ruby-china.com/pub/ruby" &gt; ~/.rvm/user/db ](https://hexo.io/docs/generating.html) 访问railsrails server默认只对本机有效，这个地方。。。坑了我太久了。。。 如要其他机器访问，请使用 1$ rails server -b 0.0.0.0 RubyMine连接虚拟机上的解释器https://www.jetbrains.com/help/ruby/configuring-remote-interpreters-using-vagrant.html 1、在settings里的Languages&amp;Frameworks Ctrl+Alt+S调出Ruby SDK and Gems，Alt+Insert添加new remote 2、选择Vagrant，找到vagrant虚拟机的路径 3、然后指定rvm或者ruby在该虚拟机下的路径 ，点击ok即可 4、接下来就可以在本地调试了]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F03%2Frails%2F</url>
    <content type="text"><![CDATA[Rails学习总结Rails 应用架构 文件/文件夹 作用 app/ 包含应用的controllers、models、views、helpers、mailers、channels、jobs、静态资源文件。 bin/ 包含用于启动应用的 rails 脚本，以及用于安装、更新、部署或运行应用的其他脚本。 config/ 配置应用的路由、数据库等。详情请参阅配置 Rails 应用。 config.ru 基于 Rack 的服务器所需的 Rack 配置，用于启动应用。 db/ 包含当前数据库的模式，以及数据库迁移文件。 Gemfile, Gemfile.lock 这两个文件用于指定 Rails 应用所需的 gem 依赖。Bundler gem 需要用到这两个文件。关于 Bundler 的更多介绍，请访问 Bundler 官网。 lib/ 应用的扩展模块。 log/ 应用日志文件。 public/ 仅有的可以直接从外部访问的文件夹，包含静态文件和编译后的静态资源文件。 Rakefile 定位并加载可在命令行中执行的任务。这些任务在 Rails 的各个组件中定义。如果要添加自定义任务，请不要修改 Rakefile，直接把自定义任务保存在 lib/tasks 文件夹中即可。 README.md 应用的自述文件，说明应用的用途、安装方法等。 test/ 单元测试、固件和其他测试装置。详情请参阅Rails 应用测试指南。 tmp/ 临时文件（如缓存和 PID 文件）。 vendor/ 包含第三方代码，如第三方 gem。 .gitignore 告诉 Git 要忽略的文件（或模式）。详情参见 GitHub 帮助文档。 类(class)、模块(module)、块、方法类 initialize方法 initialize 方法是一个标准的 Ruby 类方法，是类的构造函数，与其他面向对象编程语言中的 constructor 工作原理类似。 12345class Box def initialize(w,h) @width, @height = w, h endend 实例变量 实例变量是类属性，它们在使用类创建对象时就变成对象的属性。每个对象的属性是单独赋值的，和其他对象之间不共享值。在类的内部，是使用 @ 运算符访问这些属性，在类的外部，则是使用称为访问器方法的公共方法进行访问。 123456class Box def initialize(w,h) # 给实例变量赋值 @width, @height = w, h endend getter &amp; setter方法 12345678910111213141516# 访问器方法def printWidth @widthend def printHeight @heightend # 设置器方法def setWidth=(value) @width = valueenddef setHeight=(value) @height = valueend !!! Ruby 定义了 attr_accessor :variable_name attr_reader :variable_name attr_writer :variable_name 三种属性声明方法。 其中：accessor=reader+writer。 同时注意：变量名前一定要带冒号: 变量名之间要用逗号, 分割。 123456789101112class Test attr_accessor :name def initialize() @name = "yanzilee9292" end end #test t = Test.newputs t.namet.name = "abcc" Rails常见命令行命令 完整形式 含义 $ rails server 开启服务器！！rails server默认只对本机有效用其他机器访问（开虚拟机的时候）使用$ rails server -b 0.0.0.0-b 选项把 Rails 绑定到指定的 IP（默认为 localhost）。指定 -d 选项后，服务器会以守护进程的形式运行。如果想让服务器监听其他端口，可通过 -p 选项指定。所处的环境（默认为开发环境）可由 -e 选项指定。$ rails server -e production -p 4000 $ rails console $ rails generate GENERATOR [args] [options] $ rails test $ rails routes 列出标准 REST 动作都具有对应的路由。 $ bundle install $ rails about 输出以下信息：Ruby、RubyGems、Rails 的版本号，Rails 使用的组件，应用所在的文件夹，Rails 当前所处的环境名，应用使用的数据库适配器，以及数据库模式版本号。如果想向他人需求帮助，检查安全补丁对你是否有影响，或者需要查看现有 Rails 应用的状态，就可以使用这个任务。 \$rails db:migrate​\$rails db:create 命名空间 db: 中最常用的任务是 migrate 和 create，这两个任务会尝试运行所有迁移相关的任务（up、down、redo、reset）。rails db:version 在排查问题时很有用，它会输出数据库的当前版本。 Rails 的generate生成controller1$ rails generate controller Welcome index 会生成多个文件和一个路由 文件/文件夹 用途 app/controllers/welcome_controller.rb Welcome 控制器文件其中包含了方法index app/views/welcome/ app/views/welcome/index.html.erb 控制器的视图保存在这里 test/controllers/welcome_controller_test.rb 控制器的测试文件 app/helpers/welcome_helper.rb 视图辅助方法文件 app/assets/javascripts/welcome.coffee 控制器的 CoffeeScript 文件 app/assets/stylesheets/welcome.scss 控制器的样式表文件 文件名是用蛇底welcome_controller.rb命名。类名是用驼峰命名WelcomeController 12345678910111213141516create app/controllers/welcome_controller.rb route get 'welcome/index'invoke erbcreate app/views/welcomecreate app/views/welcome/index.html.erbinvoke test_unitcreate test/controllers/welcome_controller_test.rbinvoke helpercreate app/helpers/welcome_helper.rbinvoke test_unitinvoke assetsinvoke coffeecreate app/assets/javascripts/welcome.coffeeinvoke scsscreate app/assets/stylesheets/welcome.scss model1$ rails generate model Article title:string text:text 生成Article模型，成员：字符串类型的title和文本类型的text。 为此 Rails 会创建一堆文件。这里我们只关注 app/models/article.rb 和 db/migrate/20140120191729_create_articles.rb 这两个文件。 Active Record 很智能，能自动把数据表的字段名映射到模型属性上，因此无需在 Rails 模型中声明属性，让 Active Record 自动完成即可。 运行迁移 1$ rails db:migrate Rails 很智能，只会运行针对当前数据库还没有运行过的迁移 撤销命令控制器 12$ rails generate controller StaticPages home help$ rails destroy controller StaticPages home help 模型 12$ rails generate model User name:string email:string$ rails destroy model User 迁移 12345$ rails db:migrate$ rails db:rollback特定版本迁移$ rails db:migrate VERSION=0 控制器controller1、Rails 控制器的命名约定最后一个单词使用复数形式，但也有例外，比如 ApplicationController。例如：用 ClientsController，而不是 ClientController；用 SiteAdminsController，而不是 SiteAdminController 或 SitesAdminsController。 遵守这一约定便可享用默认的路由生成器（例如 resources 等），无需再指定 :path 或 :controller 选项，而且 URL 和路径的辅助方法也能保持一致性。 2、方法和动作一个控制器是一个 Ruby 类，继承自 ApplicationController，和其他类一样，定义了很多方法。应用接到请求时，路由决定运行哪个控制器和哪个动作，然后 Rails 创建该控制器的实例，运行与动作同名的方法。 3、参数！在 Web 应用中参数分为两类。 第一类“GET数据”，即 URL 中 ? 符号后面的部分。 第二类经常称为“POST 数据”，一般来自用户填写的表单。之所以叫做“POST 数据”，是因为这类数据只能随 HTTP POST 请求发送。 Rails 不区分这两种参数，在控制器中都可通过 params 散列获取 12345678910111213141516171819202122232425class ClientsController &lt; ApplicationController # 这个动作使用GET，因为它响应的是 HTTP GET 请求 # 列出激活客户的 URL 可能是这样的：/clients?status=activated def index if params[:status] == "activated" @clients = Client.activated else @clients = Client.inactivated end end # 这个动作使用 POST 参数 # 这种参数最常来自用户提交的 HTML 表单 # 在 REST 式架构中，这个动作响应的 URL 是“/clients” def create @client = Client.new(params[:client]) if @client.save redirect_to @client else # 这一行代码覆盖默认的渲染行为 # 默认渲染的是“create”视图 render "new" end endend 1、散列和组参数params 散列不局限于只能使用一维键值对，其中可以包含数组和嵌套的散列。若想发送数组，要在键名后加上一对空方括号（[]）： 1GET /clients?ids[]=1&amp;ids[]=2&amp;ids[]=3 “[”和“]”这两个符号不允许出现在 URL 中，所以上面的地址会被编码成 /clients?ids%5b%5d=1&amp;ids%5b%5d=2&amp;ids%5b%5d=3。多数情况下，无需你费心，浏览器会代为编码，接收到这样的请求后，Rails 也会自动解码。如果你要手动向服务器发送这样的请求，就要留心了。 此时，params[:ids] 的值是 [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]。注意，参数的值始终是字符串，Rails 不会尝试转换类型。 2、JSON参数1&#123; "company": &#123; "name": "acme", "address": "123 Carrot Street" &#125; &#125; 控制器收到的 params[:company] 是 { &quot;name&quot; =&gt; &quot;acme&quot;, &quot;address&quot; =&gt; &quot;123 Carrot Street&quot; }。 如果在初始化脚本中开启了 config.wrap_parameters 选项，或者在控制器中调用了 wrap_parameters 方法，可以放心地省去 JSON 参数中的根元素。此时，Rails 会以控制器名新建一个键，复制参数，将其存入这个键名下。因此，上面的参数可以写成： 1&#123; "name": "acme", "address": "123 Carrot Street" &#125; 3、路由参数params 散列始终有 :controller 和 :action 两个键，但获取这两个值应该使用 controller_name和 action_name 方法。路由中定义的参数，例如 :id，也可通过 params 散列获取。 例如，假设有个客户列表，可以列出激活和未激活的客户。我们可以定义一个路由，捕获下面这个 URL 中的 :status参数： 1get '/clients/:status' =&gt; 'clients#index', foo: 'bar 此时，用户访问 /clients/active 时，params[:status] 的值是 &quot;active&quot;。同时，params[:foo]的值会被设为 &quot;bar&quot;，就像通过查询字符串传入的一样。控制器还会收到 params[:action]，其值为 &quot;index&quot;，以及 params[:controller]，其值为 &quot;clients&quot;。 4、default_url_options在控制器中定义名为 default_url_options 的方法，可以设置所生成的 URL 中都包含的参数。这个方法必须返回一个散列，其值为所需的参数值，而且键必须使用符号： 12345class ApplicationController &lt; ActionController::Base def default_url_options &#123; locale: I18n.locale &#125; endend 这个方法定义的只是预设参数，可以被 url_for 方法的参数覆盖。 如果像上面的代码那样在 ApplicationController 中定义 default_url_options，设定的默认参数会用于生成所有的 URL。default_url_options 也可以在具体的控制器中定义，此时只影响与该控制器有关的 URL。 其实，不是生成的每个 URL 都会调用这个方法。为了提高性能，返回的散列会缓存，因此一次请求至少会调用一次。 5、健壮参数加入健壮参数功能后，Action Controller 的参数禁止在 Avtive Model 中批量赋值，除非参数在白名单中。也就是说，你要明确选择哪些属性可以批量更新，以防不小心允许用户更新模型中敏感的属性。 此外，还可以标记哪些参数是必须传入的，如果没有收到，会交由预定义的 raise/rescue 流程处理，返回“400 Bad Request”。 123456789101112131415161718192021222324class PeopleController &lt; ActionController::Base # 这会导致 ActiveModel::ForbiddenAttributesError 异常抛出 # 因为没有明确指明允许赋值的属性就批量更新了 def create Person.create(params[:person]) end # 只要参数中有 person 键，这个动作就能顺利执行 # 否则，抛出 ActionController::ParameterMissing 异常 # ActionController::Base 会捕获这个异常，返回 400 Bad Request 响应 def update person = current_account.people.find(params[:id]) person.update!(person_params) redirect_to person end private # 在一个私有方法中封装允许的参数是个好做法 # 这样可以在 create 和 update 动作中复用 # 此外，可以细化这个方法，针对每个用户检查允许的属性 def person_params params.require(:person).permit(:name, :age) endend 1、允许使用的标量值如果允许使用:id: 1params.permit(:id) 若 params 中有 :id 键，且 :id 是标量值，就可以通过白名单检查；否则 :id 会被过滤掉。因此，不能传入数组、散列或其他对象。 允许使用的标量类型有：String、Symbol、NilClass、Numeric、TrueClass、FalseClass、Date、Time、DateTime、StringIO、IO、ActionDispatch::Http::UploadedFile 和 Rack::Test::UploadedFile。 若想指定 params 中的值必须为标量数组，可以把键对应的值设为空数组： 1params.permit(id: []) 有时无法或不便声明散列参数或其内部结构的有效键，此时可以映射为一个空散列： 1params.permit(preferences: &#123;&#125;) 模型1、命名约定Rails 把模型的类名转换成复数，然后查找对应的数据表。 例如，模型类名为 Book，数据表就是 books。Rails 提供的单复数转换功能很强大，常见和不常见的转换方式都能处理。如果类名由多个单词组成，应该按照 Ruby 的约定，使用驼峰式命名法，这时对应的数据库表将使用下划线分隔各单词。 数据库表名：复数，下划线分隔单词（例如 book_clubs） 模型类名：单数，每个单词的首字母大写（例如 BookClub） | 模型/类 | 表/模式 || :——— | :———– || Article | articles || LineItem | line_items || Deer | deers || Mouse | mice || Person | people | 关联关系六种 belongs_to has_one has_many has_many :through has_one :through has_and_belongs_to_many 关联使用宏式调用 实现，用声明的形式为模型添加功能。例如，声明一个模型属于（belongs_to）另一个模型后，Rails 会维护两个模型之间的“主键-外键”关系，而且还会向模型中添加很多实用的方法。 1、belongs_to 123class Book &lt; ApplicationRecord belongs_to :authorend Book模型自动关联到Author模型，但是数据表名其实是复数的，在 belongs_to 关联声明中必须使用单数形式。如果在上面的代码中使用复数形式定义 author 关联，应用会报错，提示“uninitialized constant Book::Authors”。 这是因为 Rails 自动使用关联名推导类名。如果关联名错误地使用复数，推导出的类名也就变成了复数。 前后端分离 https://ruby-china.org/topics/31660 把返回值转化为json 12345678910111213141516171819202122232425262728293031323334353637383940class EmployeesController &lt; ApplicationController def index #@employees = Employee.all json_str = Employee.all.to_json render :json=&gt;json_str, status=&gt;'200' end def new end def show @employee = Employee.find(params[:id]) end def create @employee = Employee.new(employee_params) @employee.save json_str = @employee.to_json render :json=&gt;json_str, status=&gt;'200' end def update @employee = Employee.find(params[:id]) if @employee.update(employee_params) json_str = @employee.to_json render :json=&gt;json_str, status=&gt;'200' else render 'edit' end end def destroy @employee = Employee.find(params[:id]) @employee.destroy json_str = @employee.to_json render :json=&gt;json_str, status=&gt;'200' end private def employee_params params.permit(:name, :gender,:age,:telephone) endend 视图和渲染创建响应三种响应方法： 调用 render 方法，向浏览器发送一个完整的响应； 调用 redirect_to 方法，向浏览器发送一个 HTTP 重定向状态码； 调用 head 方法，向浏览器发送只含 HTTP 首部的响应； 1、默认渲染行为在某个动作（class中的函数）末尾并没有指定要渲染视图，Rails 会自动在控制器的视图文件夹中寻找 app/views/类s/动作名.html.erb 模板，然后渲染。 例如 1234567891011#app/controllers/books_controller.rbclass BooksController &lt; ApplicationController def index endend#config/routes.rbresources :books#app/views/books/index.html.erb&lt;h1&gt;Books are coming soon!&lt;/h1&gt; 访问/books的时候，rails自动寻找app/views/books/index.html.erb中的视图进行渲染。 2、render方法render 方法的行为有多种定制方式，可以渲染 Rails 模板的默认视图、指定的模板、文件、行间代码或者什么也不渲染。渲染的内容可以是文本、JSON 或 XML。而且还可以设置响应的内容类型和 HTTP 状态码。 如果不想使用浏览器而直接查看调用 render 方法得到的结果，可以调用 render_to_string 方法。它与 render 的用法完全一样，但是不会把响应发给浏览器，而是直接返回一个字符串。 render方法的选项： :content_type 默认情况下，Rails 渲染得到的结果内容类型为 text/html（如果使用 :json 选项，内容类型为 application/json；如果使用 :xml 选项，内容类型为 application/xml）。如果需要修改内容类型，可使用 :content_type 选项。 1render file: filename, content_type: "application/rss" :layout :location :status Rails 会自动为生成的响应附加正确的 HTTP 状态码（大多数情况下是 200 OK）。使用 :status 选项可以修改状态码。 :formats Rails 使用请求中指定的格式（或者使用默认的 :html）。如果想改变格式，可以指定 :formats 选项。它的值是一个符号或一个数组。 1、渲染action的view渲染同个控制器中的其他模板，把视图的名字（用字符串或符号的形式）传给 render 方法 123456789101112def update @book = Book.find(params[:id]) if @book.update(book_params) redirect_to(@book) else render "edit" #也可以写成 #render :edit #render action: :edit #render (action: :edit) endend 2、渲染其他controller中某个action的view1234render "products/show"或者render template: "products/show"#template是一个选项？ 3、渲染任意文件12render file: "/u/apps/warehouse_app/current/app/views/products/show"#应用之外的视图 4、渲染文本调用 render 方法时指定 :plain 选项，可以把没有标记语言的纯文本发给浏览器 1render plain: "OK" 5、渲染html1render html: "&lt;strong&gt;Not Found&lt;/strong&gt;".html_safe 6、渲染jsonJSON 是一种 JavaScript 数据格式，很多 Ajax 库都用这种格式。Rails 内建支持把对象转换成 JSON，经渲染后再发送给浏览器。 1render json: @product 7、渲染xml1render xml: @product 3、 redirect_to 方法render 告诉 Rails 构建响应时使用哪个视图（或其他静态资源）。redirect_to 做的事情则完全不同，它告诉浏览器向另一个 URL 发起新请求。例如，在应用中的任何地方使用下面的代码都可以重定向到 photos 控制器的 index 动作 1redirect_to photos_url 区别render和redirect_to 12345678910111213141516171819202122def index @books = Book.allend#renderdef show @book = Book.find_by(id: params[:id]) if @book.nil? render action: "index" #不会执行index动作，只会去寻找相应的视图 endend#redirect_todef show @book = Book.find_by(id: params[:id]) if @book.nil? redirect_to action: :index #浏览器会向 index 页面发起新请求，执行 index 方法中的代码 endend 4、head构建只有首部的响应123456789101112head :bad_request#生成的首部文件：HTTP/1.1 400 Bad RequestConnection: closeDate: Sun, 24 Jan 2010 12:15:53 GMTTransfer-Encoding: chunkedContent-Type: text/html; charset=utf-8X-Runtime: 0.013483Set-Cookie: _blog_session=...snip...; path=/; HttpOnlyCache-Control: no-cache Session会话]]></content>
  </entry>
  <entry>
    <title><![CDATA[git操作]]></title>
    <url>%2F2019%2F04%2F03%2Fgit%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[操作图this text is green git三棵树 树 用途 HEAD 上一次提交的快照，下一次提交的父结点 Index 预期的下一次提交的快照 Working Directory 沙盒 HEADHEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 你的上一次提交 的快照。 Index索引索引是你的 预期的下一次提交。 我们也会将这个概念引用为 Git 的 “暂存区域”，这就是当你运行 git commit 时 Git 看起来的样子。 Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。 工作目录你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。 分支操作查看分支 列出本地所有分支 星号代表当前HEAD指向的分支 123456$ git branch $ git branch --list iss53* master testing 查看分支的最后一次提交 1234$ git branch -v iss53 93b412c fix javascript issue* master 7a98805 Merge branch 'iss53' testing 782fd34 add scott to the author list in the readmes 查看哪些分支已经合并到当前分支 1234$ git branch --merged iss53* master$ git branch -d iss53 说明iss53已经合并到当前分支，可以用删除掉，没有任何影响 查看未合并的分支 123456$ git branch --no-merged testing$ git branch -d testing error: The branch 'testing' is not fully merged.If you are sure you want to delete it, run 'git branch -D testing'.$ git branch -D testing 没有合并的分支无法用-d来删除，可以用-D强制删除 列出本地和远程的所有分支 1$ git branch -a 列出远程分支 1$ git branch -r 新建分支1$ git checkout newbranch 远程分支本地分支关联远程分支 123456$ touch README.md$ git init$ git add README.md$ git commit -m "first commit"$ git remote add origin https://xxxxxxx/wangdong/helloworld.git #关联远程分支$ git push -u origin master 解除远程分支的关联： 1$ git remote remove origin 重新关联远程分支： 1$ git remote add origin https://dev.33.cn/wangdong/alioss-file.git 远程仓库的使用查看远程仓库可以运行 git remote 命令。 它会列出你指定的每一个远程服务器的简写。 你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。 Git pushgit push的一般形式为 1$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 例如下：即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名 1$ git push origin master:refs/for/master ​ 第一个master是本地分支名，第二个master是远程分支名。 1. git push origin master 如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建 2. git push origin :refs/for/master 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支 等同于 git push origin –delete master 3. git push origin 如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支 4. git push 如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用git branch -r ，查看远程的分支名 5 git push 的其他命令 这几个常见的用法已足以满足我们日常开发的使用了，还有几个扩展的用法，如下： （1） git push -u origin master 如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用git push不带任何参数的git push，默认只推送当前分支，这叫做simple方式，还有一种matching方式，会推送所有有对应的远程分支的本地分支， Git 2.0之前默认使用matching，现在改为simple方式 如果想更改设置，可以使用git config命令。 123456789$ git config --global push.default matching或者$ git config --global push.default simple查看配置$ git config -l （2） git push –all origin 当遇到这种情况就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要 -all 选项 （3） git push –force origin git push的时候需要本地先git pull更新到跟服务器版本一致，如果本地版本库比远程服务器上的低，那么一般会提示你git pull更新，如果一定要提交，那么可以使用这个命令。 （4） git push origin –tags git push 的时候不会推送标签，如果一定要推送标签的话那么可以使用这个命令 .gitignore项目开发过程中修改了gitignore，未生效，因为gitignore只能忽略原来没有被track的文件，如果某些文件已经被纳入了版本管理中，此时修改gitignore文件不会马上生效，需要先把本地cache删除，改变成为track的状态，再提交。 123$ git rm -r --cached .$ git add .$ git commit -m "update gitignore" git pull将远程存储库中的更改合并到当前分支中。在默认模式下，git pull是git fetch后跟git merge FETCH_HEAD的缩写。 更准确地说，git pull使用给定的参数运行git fetch，并调用git merge将检索到的分支头合并到当前分支中。 使用--rebase，它运行git rebase而不是git merge。 git撤销操作commit重新提交有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 --amend 选项的提交命令尝试重新提交： 1$ git commit --amend 123$ git commit -m 'initial commit'$ git add forgotten_file$ git commit --amend 最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。 取消stage的文件—reset操作你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 git add * 暂存了它们两个。 如何只取消暂存两个中的一个呢？ git status 命令提示了你： 12345678$ git add *$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) renamed: README.md -&gt; README modified: CONTRIBUTING.md 然后使用git reset HEAD 12345678910111213141516$ git reset HEAD CONTRIBUTING.mdUnstaged changes after reset:M CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) renamed: README.md -&gt; READMEChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: CONTRIBUTING.md 对工作区文件进行修改，想恢复–checkout你之前commit过一次，已经加入了index中，现在在工作区修改了文件，但是想还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子） 1$ git checkout -- CONTRIBUTING.md 你需要知道 git checkout -- [file] 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。 HEAD Index Workdir WD Safe? Commit Level reset --soft [commit] REF NO NO YES reset [commit] REF YES NO YES reset --hard [commit] REF YES YES NO checkout [commit] HEAD YES YES YES File Level reset (commit) [file] NO YES NO YES checkout (commit) [file] NO YES YES NO a = Article.new(title:”第一期送书活动 | 获奖名单公布”,publish_time:Time.now,cover_picture_url:”/articles/yuhang_1.jpg”,original_url:”https://mp.weixin.qq.com/s/I0xW8m2OsXaRcZY_0iIJWQ&quot;,club_id:4)]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
